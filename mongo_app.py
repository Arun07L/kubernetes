"""
This module allows users to manage the CRUD operations for tasks in a TODO application.
It provides endpoints for creating, reading, updating, and deleting tasks,
along with a bulk creation feature. Each task is stored in a MongoDB collection with a custom ID generation.
"""

from flask import Flask, request, jsonify
from pymongo import MongoClient,ReturnDocument

app = Flask(__name__)
app.config['MONGO_URI'] = 'mongodb://localhost:27017'
client = MongoClient(app.config['MONGO_URI'])
db = client.get_database('todo_db')

# Collection reference
todo_collection = db.todos

def get_id():
    """
    Increments and Retrieves the current sequence value in the 'todo_id' counter.

    This function updates the 'seq' field in the 'todo_id' document within the MongoDB collection.
    It atomically increments the sequence value by 1 and returns the updated value.

    Returns:
        int: The updated sequence value after incrementing.
    """
    counter = todo_collection.find_one_and_update(
        {'_id': 'todo_id'},
        {'$inc': {'seq': 1}},
        return_document=ReturnDocument.AFTER,
        upsert=True
    )
    return counter['seq']

def get_ids(count):
    """
    Increments and Retrieves the current sequence value to generate a range of IDs in the 'todo_id' counter.

    This function updates the 'seq' field in the 'todo_id' document within the MongoDB collection.
    It atomically increments the sequence value by the specified number of IDs (count) and returns a tuple
    containing the start and end of the ID range.

    Args:
        count (int): The number of sequential IDs to generate.

    Returns:
        tuple: A tuple containing two integers:
            - The starting sequence value for the range of IDs.
            - The ending sequence value for the range of IDs.
    """
    counter = todo_collection.find_one_and_update(
        {'_id': 'todo_id'},
        {"$inc": {"seq": count}},
        return_document=ReturnDocument.AFTER,
        upsert=True
    )
    return counter['seq'] - count + 1, counter['seq']
def home_func():
    """
    This function handles the default route and returns a welcome message.

    Returns:
        response (json): A JSON response containing a welcome message.
    """
    return jsonify({'message': "Welcome to TODO Application"}),200

def create_func():
    """
    This function creates a new Todo task with a custom ID generated by incrementing a counter stored in the app config.

    The task data should be provided in the request body as a JSON object with the following fields:
    - title: The title of the task (string).
    - description: A brief description of the task (string).
    - status: The current status of the task (string).

    Returns:
        response (json): A JSON response containing a success message and the generated ID for the task.
    """
    data = request.get_json()
    todo = {
        'title': data['title'],
        'description': data['description'],
        'status': data['status'],
        '_id': get_id()
    }
    todo_collection.insert_one(todo)
    return jsonify({'message': 'Task added successfully', '_id': todo['_id']}), 201

def create_bulk():
    """
    This function allows the creation of multiple Todo tasks in a single request.
    Custom IDs are generated for each task using the current value of the counter stored in the app config.

    The tasks data should be provided in the request body as a JSON array of objects.
    Each object should contain the following fields:
    - title: The title of the task (string).
    - description: A brief description of the task (string).
    - status: The current status of the task (string).

    Returns:
        response (json): A JSON response containing a success message.
    """
    data = request.get_json()

    count = len(data)
    start_id, end_id = get_ids(count)

    # Generate the range of IDs
    ids = list(range(start_id, end_id + 1))

    # Update the data with the generated IDs
    updated_data = list(map(lambda record, id_value: {**record, '_id': id_value}, data, ids))

    todo_collection.insert_many(updated_data)
    return jsonify({'message': 'Tasks added successfully'}), 201

def read_func(id):
    """
    This function retrieves a specific Todo task from the database using ID.

    Args:
        id (str): The ID of the task to retrieve.

    Returns:
        response (json): A JSON response containing the task data if found, otherwise a 404 error message.
    """
    todo = todo_collection.find_one({'_id': int(id)})
    if not todo:
        return jsonify({'message': 'Not found'}), 404

    return jsonify(todo), 200

def read_all_func():
    """
    This function retrieves all Todo tasks from the database.

    Returns:
        response (json): A JSON response containing all tasks in the database.
    """
    todos = todo_collection.find()
    return jsonify(todos), 200

def update_func(id):
    """
    This function updates an existing Todo task with new data.

    The updated task data should be provided in the request body as a JSON object with the following fields:
    - title: The new title of the task (string).
    - description: The new description of the task (string).
    - status: The new status of the task (string).

    Args:
        id (str): The ID of the task to update.

    Returns:
        response (json): A JSON response containing a success message if the task is found and updated,
                         otherwise a 404 error message.
    """
    data = request.get_json()
    required_fields = {'title', 'description', 'status'}

    if not required_fields.issubset(data):
        return jsonify({'message': 'Some values are missing'}), 400

    updated_task = {field: data[field] for field in required_fields}
    result = todo_collection.update_one({'id': int(id)}, {'$set': updated_task})

    if result.matched_count == 0:
        return jsonify({'message': 'Task not found'}), 404

    return jsonify({'message': 'Task updated successfully'}), 200

def partial_update_func(id):
    """
    This function partially updates an existing Todo task with the provided data.

    The fields to update should be provided in the request body as a JSON object.

    Args:
        id (str): The ID of the task to update.

    Returns:
        response (json): A JSON response containing a success message if the task is found and updated,
                         otherwise a 404 error message.
    """
    data = request.get_json()

    result = todo_collection.update_one({'id': int(id)}, {'$set': data})

    if result.matched_count == 0:
        return jsonify({'message': 'Task not found'}), 404

    return jsonify({'message': 'Task updated successfully'}), 200

def delete_func(id):
    """
    This function deletes a specific Todo task from the database using its ID.

    Args:
        id (str): The ID of the task to delete.

    Returns:
        response (json): A JSON response containing a success message if the task is found and deleted,
                         otherwise a 404 error message.
    """
    result = todo_collection.delete_one({'id': int(id)})
    if result.deleted_count == 0:
        return jsonify({'message': 'Task not found'}), 404
    return jsonify({'message': 'Task deleted successfully'}), 200

# URL rules for the API endpoints
app.add_url_rule(rule='/', view_func=home_func, methods=['GET'])
app.add_url_rule(rule='/tasks', view_func=create_func, methods=['POST'])
app.add_url_rule(rule='/tasks/bulk', view_func=create_bulk, methods=['POST'])
app.add_url_rule(rule='/tasks/<id>', view_func=read_func, methods=['GET'])
app.add_url_rule(rule='/tasks', view_func=read_all_func, methods=['GET'])
app.add_url_rule(rule='/tasks/<id>', view_func=update_func, methods=['PUT'])
app.add_url_rule(rule='/tasks/<id>', view_func=delete_func, methods=['DELETE'])
app.add_url_rule(rule='/tasks/<id>', view_func=partial_update_func, methods=['PATCH'])

if __name__ == "__main__":
    app.run(debug=True)
